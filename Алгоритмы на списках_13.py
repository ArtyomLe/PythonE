# Ищем кол-во работников заробатывающих менее 20000
zrp = [22000, 15000, 19500, 24000, 20000, 12365, 23000]

count = 0
for i in zrp:
    if(i < 20000):
        count += 1
print(f"Кол-во работников заробатывающих менее 20000 равно: {count} чел.")

# |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

# Ищем где припаркован авто
n = "311"       # Ищем где припаркован авто с номером 311
parking = ["-", "-", "132", "155", "-", "521", "-", "311", "555", "839"]

park = None
p1 = 0

while (park == None and p1 < len(parking)):
    if (parking[p1] == n):
        park = p1
    p1 += 1
if (park != None):
    print(f"Автомобиль стоит на {park} месте")
else:
    print("Автомобиля на стоянке нет")

# Ту же программу можно написать через цикл for =====================================================================

n = "311"       # Ищем где припаркован авто с номером 311
parking = ["-", "-", "132", "155", "311", "521", "-", "-", "555", "839"]

park = None

for i in range(len(parking)):
    if(parking[i] == n):
        park = i # Приравниваем park к индексу в списке который укажет на номер авто(значение) который выведем в print
#       break                    # Чтобы не перебирать весь список до конца после нахождения нужного номера авто "311"

if (park != None):
    print(f"Автомобиль стоит на {park} месте")
else:
    print("Автомобиля на стоянке нет")

# Преимущество цикла while перед for в том что операция перебора заканчивается сразу после того как (park != None)
# В то время как for будет перебирать все элементы если не воспользоваться break

# |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

# Сортировка пузырьком (последовательное сравнение двух соседних элемнтов)
sites = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]     # Список с количеством просмотра страниц

for i in range(len(sites) - 1):             # range(9)
    for j in range(len(sites) - 1 - i):     # range(9-0) => range(9-1) => range(9-2) **** (9,8,7)
        if (sites[j] < sites[j + 1]):
            sites[j], sites[j + 1] = sites[j + 1], sites[j]
print(sites)

#                                              ++++++++ ПОЯСНЕНИЯ +++++++++
#                                                      цикл[ ] = 0  1  2  3  4  5  6  7  8  9
#                                   Изначальная позиция sites = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# цикл[0] => if(1<2)  =>  [j]=1 < [j+1]=2  =>  1,2=2,1  =>      [2, 1, 3, 4, 5, 6, 7, 8, 9, 10]
# цикл[1] => if(1<3)  =>  [j]=1 < [j+1]=3  =>  1,3=3,1  =>      [2, 3, 1, 4, 5, 6, 7, 8, 9, 10]
# цикл[2] => if(1<4)  =>  [j]=1 < [j+1]=4  =>  1,4=4,1  =>      [2, 3, 4, 1, 5, 6, 7, 8, 9, 10]
#                                                               *******************************
#                                                               [2, 3, 4, 5, 6, 7, 8, 9, 1, 10]
# цикл[8] => if(1<10)  =>  [j]=1 < [j+1]=10  =>  1,10=10,1  =>  [2, 3, 4, 5, 6, 7, 8, 9, 10, 1]

# ++ ЦИКЛ i УВЕЛИЧИВАЕТСЯ НА 1 ++(в j уменьшается общее кол-во циклов на 1 "нет смысла сравнивать 2 и 1 в конце списка")
#                                                      цикл[ ] = 0  1  2  3  4  5  6  7  8  9
#                   После прохождения первого цикла (j) sites = [2, 3, 4, 5, 6, 7, 8, 9, 10, 1]
# цикл[0] => if(2<3)  =>  [j]=2 < [j+1]=3  =>  2,3=3,2  =>      [3, 2, 4, 5, 6, 7, 8, 9, 10, 1]
# цикл[1] => if(2<4)  =>  [j]=2 < [j+1]=4  =>  2,4=4,2  =>      [3, 4, 2, 5, 6, 7, 8, 9, 10, 1]
#                                                               *******************************
#                                                               [3, 4, 5, 6, 7, 8, 9, 2, 10, 1]
# цикл[7] => if(2<10)  =>  [j]=2 < [j+1]=10  =>  2,10=10,2  =>  [3, 4, 5, 6, 7, 8, 9, 10, 2, 1]

# В итоге получаем элемент с максимальным значением переходит на первое место => sites = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

# ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||